{-# LANGUAGE FlexibleInstances #-}

-- (c) Alex McLean and contributors 2022
-- Shared under the terms of the GNU Public License v3.0

-- Please do not edit this file directly, it's generated from
-- bin/generate-composers.hs

module Sound.Tidal.Signal.Compose where

import Prelude hiding ((<*), (*>))
import Control.Monad (forM)
import Data.Bits

import qualified Data.Map.Strict as Map

import Sound.Tidal.Types
import Sound.Tidal.Signal.Base

-- ************************************************************ --
-- Hack to allow 'union' to be used on any value

-- class for types that support a left-biased union
class Unionable a where
  union :: a -> a -> a

-- default union is just to take the left hand side..
instance Unionable a where
  union = const

instance {-# OVERLAPPING #-} Unionable ValueMap where
  union = Map.union

-- ************************************************************ --

opMix :: Applicative t => (a -> b -> c) -> t a -> t b -> t c
opMix f a b = f <$> a <*> b

opIn :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
opIn f a b = f <$> a <* b
  
opOut :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
opOut f a b = f <$> a *> b

opSqueeze :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
opSqueeze f a b = squeezeJoin $ fmap (\a -> fmap (\b -> f a b)  b) a
  
opSqueezeOut :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
opSqueezeOut f pata patb = squeezeJoin $ fmap (\a -> fmap (\b -> f b a)  pata) patb

opTrig :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
opTrig f a b = trigJoin $ fmap (\a -> fmap (\b -> f a b)  b) a
  
opTrigzero :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
opTrigzero f a b = trigzeroJoin $ fmap (\a -> fmap (\b -> f a b)  b) a

-- ************************************************************ --

-- Aliases

(#) :: Unionable b => Signal b -> Signal b -> Signal b
(#) = (|=)

struct :: Unionable a => Signal Bool -> Signal a -> Signal a
struct = flip keepifOut

structAll :: Unionable a => Signal a -> Signal a -> Signal a
structAll = flip keepOut

mask :: Unionable a => Signal Bool -> Signal a -> Signal a
mask = flip keepifIn

maskAll :: Unionable a => Signal a -> Signal a -> Signal a
maskAll = flip keepIn

reset :: Unionable a => Signal Bool -> Signal a -> Signal a
reset = flip keepifTrig

resetAll :: Unionable a => Signal a -> Signal a -> Signal a
resetAll = flip keepTrig

restart :: Unionable a => Signal Bool -> Signal a -> Signal a
restart = flip keepifTrigzero

restartAll :: Unionable a => Signal a -> Signal a -> Signal a
restartAll = flip keepTrigzero

-- ************************************************************ --

