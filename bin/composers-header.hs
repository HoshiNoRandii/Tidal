{-# LANGUAGE FlexibleInstances #-}

-- (c) Alex McLean and contributors 2022
-- Shared under the terms of the GNU Public License v3.0

-- Please do not edit this file directly, it's generated from
-- bin/generate-composers.hs

module Sound.Tidal.Signal.Compose where

import           Control.Monad           (forM)
import           Data.Bits
import           Prelude                 hiding ((*>), (<*))

import qualified Data.Map.Strict         as Map

import           Sound.Tidal.Pattern
import           Sound.Tidal.Signal.Base
import           Sound.Tidal.Types

-- ************************************************************ --
-- Hack to allow 'union' to be used on any value

-- class for types that support a left-biased union
class Unionable a where
  union :: a -> a -> a

-- default union is just to take the left hand side..
instance Unionable a where
  union = const

instance {-# OVERLAPPING #-} Unionable ValueMap where
  union = Map.union

-- ************************************************************ --

opMix :: Applicative t => (a -> b -> c) -> t a -> t b -> t c
opMix f a b = f <$> a <*> b

opIn :: Pattern p => (a -> b -> c) -> p a -> p b -> p c
opIn f a b = f <$> a <* b

opOut :: Pattern p => (a -> b -> c) -> p a -> p b -> p c
opOut f a b = f <$> a *> b

opSqueeze :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
opSqueeze f a b = squeezeJoin $ fmap (\a -> fmap (\b -> f a b)  b) a

opSqueezeOut :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
opSqueezeOut f pata patb = squeezeJoin $ fmap (\a -> fmap (\b -> f b a)  pata) patb

opTrig :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
opTrig f a b = trigJoin $ fmap (\a -> fmap (\b -> f a b)  b) a

opTrigzero :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
opTrigzero f a b = trigzeroJoin $ fmap (\a -> fmap (\b -> f a b)  b) a

-- ************************************************************ --

-- Aliases

(#) :: (Pattern p, Unionable a) => p a -> p a -> p a
(#) = (|=)

struct :: (Pattern p, Unionable a) => p Bool -> p a -> p a
struct = flip keepifOut

structAll :: (Pattern p, Unionable a) => p a -> p a -> p a
structAll = flip keepOut

mask :: (Pattern p, Unionable a) => p Bool -> p a -> p a
mask = flip keepifIn

maskAll :: (Pattern p, Unionable a) => p a -> p a -> p a
maskAll = flip keepIn

reset :: (Unionable a) => Signal Bool -> Signal a -> Signal a
reset = flip keepifTrig

resetAll :: (Unionable a) => Signal a -> Signal a -> Signal a
resetAll = flip keepTrig

restart :: (Unionable a) => Signal Bool -> Signal a -> Signal a
restart = flip keepifTrigzero

restartAll :: (Unionable a) => Signal a -> Signal a -> Signal a
restartAll = flip keepTrigzero

-- ************************************************************ --

